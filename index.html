<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>信号支援システム - 縦型 HMI</title>
    <!-- ONNX Runtime Web -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <style>
        :root {
            --accent-color: #00e5ff;
            --alert-green: #00ff66;
            --alert-red: #ff2222;
            --bg-panel: rgba(15, 20, 25, 0.9);
            --bg-hmi: rgba(0, 0, 0, 0.85);
        }

        body {
            margin: 0;
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif;
            overflow: hidden;
        }

        /* Redmi Note 13 Pro+ の縦長比率 (約20:9) に強制する設定 */
        #app-container {
            position: relative;
            height: 100vh;
            aspect-ratio: 9 / 20; 
            max-width: 100vw;
            background: #000;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        /* 背面カメラ映像：画面全体に表示 */
        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }

        /* AI解析用・枠描画キャンバス */
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        /* 開発用ステータス（左上：バージョン表示追加） */
        #dev-status {
            position: absolute;
            top: env(safe-area-inset-top, 10px);
            left: 10px;
            z-index: 200;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.65rem;
            text-transform: uppercase;
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 4px;
        }

        /* 信号モニター（上部中央） */
        #signal-monitor {
            position: absolute;
            top: calc(env(safe-area-inset-top, 10px) + 15px);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            background: rgba(0,0,0,0.5);
            padding: 8px 25px;
            border-radius: 30px;
            z-index: 150;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
        }
        .monitor-light {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #222;
            transition: background 0.15s;
        }
        .monitor-light.red.active { background: var(--alert-red); box-shadow: 0 0 15px var(--alert-red); }
        .monitor-light.blue.active { background: var(--alert-green); box-shadow: 0 0 15px var(--alert-green); }

        /* --- HMI ポップアップ共通 --- */
        .hmi-popup {
            position: absolute;
            top: 42%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            background: var(--bg-hmi);
            border: 2px solid #444;
            border-radius: 35px;
            padding: 35px 15px;
            z-index: 100;
            display: none;
            flex-direction: column;
            align-items: center;
            text-align: center;
            pointer-events: none;
            box-shadow: 0 15px 50px rgba(0,0,0,0.8);
        }

        .hmi-popup h1 { margin: 15px 0 0 0; font-size: 1.8rem; font-weight: 900; }

        /* 各種HMIデザイン */
        #red-alert-hmi { border-color: var(--alert-red); animation: red-flash 0.3s infinite alternate; }
        #red-alert-hmi h1 { color: var(--alert-red); }
        @keyframes red-flash { from { border-color: rgba(255,34,34, 0.3); } to { border-color: rgba(255,34,34, 1); } }

        #blue-notice-hmi { border-color: var(--alert-green); animation: pop-in 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        #blue-notice-hmi h1 { color: var(--alert-green); }

        #standby-hmi { display: flex; border-color: var(--accent-color); }
        #standby-hmi h1 { color: var(--accent-color); font-size: 1.2rem; }
        
        .scanning-pulse {
            width: 45px; height: 45px;
            background: var(--accent-color);
            border-radius: 50%;
            animation: breathing 3s ease-in-out infinite;
            opacity: 0.4;
        }
        @keyframes breathing {
            0%, 100% { transform: scale(0.8); opacity: 0.2; }
            50% { transform: scale(1.1); opacity: 0.5; box-shadow: 0 0 15px var(--accent-color); }
        }

        @keyframes pop-in {
            0% { transform: translate(-50%, -40%) scale(0.9); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* 下部メインパネル */
        #status-panel {
            position: absolute;
            bottom: calc(env(safe-area-inset-bottom, 10px) + 80px);
            left: 5%;
            width: 90%;
            z-index: 50;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .status-card {
            background: var(--bg-panel);
            border-radius: 15px;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(15px);
        }
        .label { color: var(--accent-color); font-size: 0.8rem; font-weight: bold; }
        .value { color: #fff; font-size: 1.4rem; font-family: monospace; font-weight: bold; }

        /* 実機テスト用（右上に配置） */
        #test-controls {
            position: absolute;
            top: 70px;
            right: 15px;
            z-index: 200;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .test-btn {
            background: rgba(255,255,255,0.15);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 10px;
            border-radius: 10px;
            font-size: 0.7rem;
            cursor: pointer;
            backdrop-filter: blur(5px);
            user-select: none;
        }

        /* スタート画面 */
        #start-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 300;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding: 20px; text-align: center;
        }
        #start-btn {
            background: var(--accent-color); color: #000; border: none;
            padding: 20px 50px; font-size: 1.8rem; font-weight: bold;
            border-radius: 60px;
            cursor: pointer;
        }
    </style>
</head>
<body>

<div id="app-container">
    <div id="dev-status">SYS: 待機中</div>

    <video id="video" autoplay playsinline muted></video>
    <!-- AI解析・描画用 -->
    <canvas id="canvas"></canvas>

    <div id="signal-monitor">
        <div id="mon-red" class="monitor-light red"></div>
        <div id="mon-blue" class="monitor-light blue"></div>
    </div>

    <!-- 1: 赤信号警告 -->
    <div id="red-alert-hmi" class="hmi-popup">
        <svg viewBox="0 0 100 100" width="80" height="80">
            <circle cx="50" cy="50" r="45" fill="none" stroke="#ff2222" stroke-width="8"/>
            <line x1="30" y1="30" x2="70" y2="70" stroke="#ff2222" stroke-width="12"/>
            <line x1="70" y1="30" x2="30" y2="70" stroke="#ff2222" stroke-width="12"/>
        </svg>
        <h1>止まれ！！</h1>
        <p style="color:#ccc; margin-top:10px; font-size: 0.9rem;">信号が赤です</p>
    </div>

    <!-- 2: 青信号通知 -->
    <div id="blue-notice-hmi" class="hmi-popup">
        <svg viewBox="0 0 120 80" width="100" height="70">
            <path d="M20,60 L100,60 L95,35 L25,35 Z" fill="#00ff66" opacity="0.3"/>
            <rect x="30" y="45" width="60" height="15" rx="5" fill="#00ff66"/>
            <path d="M40,35 L80,35 L75,20 L45,20 Z" fill="#00ff66"/>
            <path d="M100,40 L130,45 L100,50 Z" fill="#00ff66" transform="translate(-10,0)"/>
        </svg>
        <h1>発進できます</h1>
    </div>

    <!-- 3: 監視中（デフォルト） -->
    <div id="standby-hmi" class="hmi-popup">
        <div class="scanning-pulse"></div>
        <h1>監視中</h1>
    </div>

    <div id="status-panel">
        <div class="status-card">
            <span class="label">信号認識</span>
            <span id="recognition-status" class="value" style="color:#666;">未検出</span>
        </div>
        <div class="status-card">
            <span class="label">車両状態</span>
            <span id="drive-status" class="value" style="color:#ffcc00;">停車</span>
        </div>
        <div class="status-card">
            <span class="label">加速度</span>
            <span id="acc-status" class="value">0.00G</span>
        </div>
    </div>

    <!-- 実機確認用テストボタン -->
    <div id="test-controls">
        <button class="test-btn" id="btn-test-red">赤警告(TEST)</button>
        <button class="test-btn" id="btn-test-blue">青通知(TEST)</button>
    </div>

    <div id="start-overlay">
        <h1 style="color: #fff; margin-bottom: 25px; font-size: 1.8rem;">運転支援システム</h1>
        <p style="color:#666; margin-bottom: 30px; font-size: 0.8rem;">Redmi Note 13 Pro+ 専用</p>
        <button id="start-btn">開始</button>
    </div>
</div>

<script>
    /**
     * --- パラメータ・設定セクション ---
     */
    const CONFIG = {
        VERSION: "v1.0.4",
        MODEL_PATH: './best.onnx',
        INPUT_SIZE: 320,
        SCORE_THRESHOLD: 0.5,
        ACC: {
            THRESHOLD: 1.2,        // 走行判定しきい値
            STOP_THRESHOLD: 0.8,   // 停車判定しきい値
            STOP_DELAY_MS: 1500,   // 停車確定までの遅延
            LPF_ALPHA: 0.1         // ローパスフィルタ係数
        },
        AUDIO: {
            RED_BEEP_FREQ: 1200,
            RED_BEEP_INTERVAL: 200
        }
    };

    /**
     * --- グローバルステート ---
     */
    let session = null;
    let audioCtx = null;
    let isMoving = false;
    let smoothedAcc = 0;
    let lastStopTimestamp = 0;
    let isInferenceRunning = false;
    let currentSignalState = 'none'; // 'red', 'blue', 'none'

    // DOM要素キャッシュ
    const elements = {
        video: document.getElementById('video'),
        canvas: document.getElementById('canvas'),
        devStatus: document.getElementById('dev-status'),
        driveLabel: document.getElementById('drive-status'),
        accLabel: document.getElementById('acc-status'),
        recognitionLabel: document.getElementById('recognition-status'),
        redHMI: document.getElementById('red-alert-hmi'),
        blueHMI: document.getElementById('blue-notice-hmi'),
        standbyHMI: document.getElementById('standby-hmi'),
        monRed: document.getElementById('mon-red'),
        monBlue: document.getElementById('mon-blue')
    };

    /**
     * --- UI・音声制御セクション ---
     */
    async function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') await audioCtx.resume();
    }

    function playRedBeep() {
        if (!audioCtx || audioCtx.state !== 'running') return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.type = 'square'; 
        osc.frequency.setValueAtTime(CONFIG.AUDIO.RED_BEEP_FREQ, audioCtx.currentTime);
        gain.gain.setValueAtTime(0, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0.12, audioCtx.currentTime + 0.01);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
        osc.start(); osc.stop(audioCtx.currentTime + 0.12);
    }

    function playBlueChime() {
        if (!audioCtx || audioCtx.state !== 'running') return;
        const now = audioCtx.currentTime;
        const playTone = (freq, start, duration) => {
            const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
            o.connect(g); g.connect(audioCtx.destination);
            o.type = 'sine'; o.frequency.setValueAtTime(freq, now + start);
            g.gain.setValueAtTime(0, now + start);
            g.gain.linearRampToValueAtTime(0.25, now + start + 0.01);
            g.gain.exponentialRampToValueAtTime(0.01, now + start + duration);
            o.start(now + start); o.stop(now + start + duration);
        };
        playTone(1318.51, 0, 0.2); playTone(1046.50, 0.12, 0.5);
    }

    function updateRecognitionUI(state) {
        currentSignalState = state;
        
        // HMI表示
        elements.redHMI.style.display = (state === 'red') ? 'flex' : 'none';
        elements.blueHMI.style.display = (state === 'blue') ? 'flex' : 'none';
        elements.standbyHMI.style.display = (state === 'none') ? 'flex' : 'none';

        // LEDインジケータ
        elements.monRed.classList.toggle('active', state === 'red');
        elements.monBlue.classList.toggle('active', state === 'blue');

        // ステータスラベル
        if (state === 'red') {
            elements.recognitionLabel.innerText = "赤信号";
            elements.recognitionLabel.style.color = "var(--alert-red)";
        } else if (state === 'blue') {
            elements.recognitionLabel.innerText = "青信号";
            elements.recognitionLabel.style.color = "var(--alert-green)";
        } else {
            elements.recognitionLabel.innerText = "未検出";
            elements.recognitionLabel.style.color = "#666";
        }
    }

    /**
     * --- センサー・デバイス初期化セクション ---
     */
    async function initCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } },
                audio: false
            });
            elements.video.srcObject = stream;
            return true;
        } catch (err) {
            elements.devStatus.innerText = "SYS: CAMERA ERROR";
            return false;
        }
    }

    function initSensor() {
        if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
            document.body.addEventListener('click', async () => {
                try { await DeviceMotionEvent.requestPermission(); } catch (e) {}
            }, { once: true });
        }

        window.addEventListener('devicemotion', (e) => {
            const acc = e.acceleration;
            if (!acc) return;
            const instantAcc = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
            smoothedAcc = smoothedAcc * (1 - CONFIG.ACC.LPF_ALPHA) + instantAcc * CONFIG.ACC.LPF_ALPHA;
            elements.accLabel.innerText = smoothedAcc.toFixed(2) + "G";
            
            const now = Date.now();
            if (smoothedAcc > CONFIG.ACC.THRESHOLD) {
                isMoving = true;
                lastStopTimestamp = now; 
            } else if (smoothedAcc < CONFIG.ACC.STOP_THRESHOLD) {
                if (now - lastStopTimestamp > CONFIG.ACC.STOP_DELAY_MS) isMoving = false;
            }
            elements.driveLabel.innerText = isMoving ? "走行" : "停車";
            elements.driveLabel.style.color = isMoving ? "#00ff66" : "#ffcc00";
        });
    }

    /**
     * --- AI推論・エンジンセクション ---
     */
    async function loadModel() {
        try {
            elements.devStatus.innerText = `SYS: MODEL LOADING... | ${CONFIG.VERSION}`;
            session = await ort.InferenceSession.create(CONFIG.MODEL_PATH, { executionProviders: ['wasm'] });
            elements.devStatus.innerText = `SYS: ACTIVE | ${CONFIG.VERSION}`;
            startInferenceLoop();
        } catch (err) {
            elements.devStatus.innerText = `SYS: MODEL ERROR | ${CONFIG.VERSION}`;
            // デモ用にシミュレーションとして継続
            setTimeout(() => { elements.devStatus.innerText = `SYS: ACTIVE (SIM) | ${CONFIG.VERSION}`; }, 2000);
        }
    }

    async function startInferenceLoop() {
        if (isInferenceRunning) return;
        isInferenceRunning = true;

        const offscreen = document.createElement('canvas');
        offscreen.width = CONFIG.INPUT_SIZE;
        offscreen.height = CONFIG.INPUT_SIZE;
        const ctx = offscreen.getContext('2d');

        async function processFrame() {
            if (!isInferenceRunning) return;
            if (elements.video.readyState === elements.video.HAVE_ENOUGH_DATA) {
                // 1. 前処理: 画像をCONFIG.INPUT_SIZEにリサイズしてテンソル化
                ctx.drawImage(elements.video, 0, 0, CONFIG.INPUT_SIZE, CONFIG.INPUT_SIZE);
                
                // ※ ここに本来はFloat32Arrayへの変換ロジックが入ります
                // 推論実行 (モデルロード済みの時のみ)
                if (session) {
                    try {
                        // 推論処理（ダミー入力例）
                        // const inputTensor = new ort.Tensor('float32', data, [1, 3, 320, 320]);
                        // const outputs = await session.run({ images: inputTensor });
                        // handleInferenceResult(outputs);
                    } catch (e) { console.error(e); }
                }
            }
            requestAnimationFrame(processFrame);
        }
        processFrame();
    }

    /**
     * --- イベントリスナー・メインエントリー ---
     */
    const startApp = async () => {
        document.getElementById('start-overlay').style.display = 'none';
        await initAudio();
        const camOk = await initCamera();
        initSensor();
        if (camOk) loadModel();
    };

    document.getElementById('start-btn').onclick = startApp;

    // テストボタン制御
    let testRedInterval;
    const testActions = {
        redStart: async () => { await initAudio(); updateRecognitionUI('red'); playRedBeep(); testRedInterval = setInterval(playRedBeep, CONFIG.AUDIO.RED_BEEP_INTERVAL); },
        redStop: () => { clearInterval(testRedInterval); updateRecognitionUI('none'); },
        blueStart: async () => { await initAudio(); updateRecognitionUI('blue'); playBlueChime(); },
        blueStop: () => { updateRecognitionUI('none'); }
    };

    const btnRed = document.getElementById('btn-test-red');
    const btnBlue = document.getElementById('btn-test-blue');

    btnRed.addEventListener('mousedown', testActions.redStart);
    btnRed.addEventListener('mouseup', testActions.redStop);
    btnRed.addEventListener('touchstart', (e) => { e.preventDefault(); testActions.redStart(); });
    btnRed.addEventListener('touchend', testActions.redStop);

    btnBlue.addEventListener('mousedown', testActions.blueStart);
    btnBlue.addEventListener('mouseup', testActions.blueStop);
    btnBlue.addEventListener('touchstart', (e) => { e.preventDefault(); testActions.blueStart(); });
    btnBlue.addEventListener('touchend', testActions.blueStop);

    // バージョン表示の初期化
    elements.devStatus.innerText = `SYS: READY | ${CONFIG.VERSION}`;
</script>
</body>
</html>
